<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Room Scenario Game</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root { --w: 1000px; }
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; }
      #wrap { max-width: var(--w); margin: 0 auto; }
      #log { width: 100%; height: 60vh; border: 1px solid #ccc; padding: 12px; overflow: auto; white-space: pre-wrap; }
      #row { margin-top: 12px; display: flex; gap: 8px; }
      #cmd { flex: 1; padding: 8px; font-size: 16px; }
      button { padding: 8px 12px; font-size: 16px; }
      #small { color: #666; font-size: 12px; margin-top: 6px; }
    </style>
  </head>
  <body>
    <div id="wrap">
      <div id="log"></div>
      <div id="row">
        <input id="cmd" type="text" placeholder="[Press Enter to start]" autocomplete="off" />
        <button id="primary">Start</button>
      </div>
      <div id="small">Enter starts, continues, or submits your move. The button does the same.</div>
    </div>

    <script>
      const log = document.getElementById("log");
      const cmd = document.getElementById("cmd");
      const btn = document.getElementById("primary");

      function scrollBottom() { log.scrollTop = log.scrollHeight; }
      function render(s) {
        log.textContent = s.transcript || "";
        btn.textContent = s.primary_label || "Start";
        cmd.placeholder = s.placeholder || "";
        // Hide the button when it's the live player's turn; otherwise show it.
        btn.style.display = (s.mode === "awaiting_action") ? "none" : "inline-block";
        // Keep focus where Enter should go
        cmd.focus();
        scrollBottom();
      }

      async function fetchState() {
        const r = await fetch("/state", { credentials: "include" });
        if (!r.ok) throw new Error("state fetch failed");
        return r.json();
      }

      async function callPrimary() {
        btn.disabled = true;
        try {
          const r = await fetch("/primary", { method: "POST", credentials: "include" });
          const s = await r.json();
          render(s);
          cmd.value = "";
        } finally {
          btn.disabled = false;
        }
      }

      async function callAction(text) {
        btn.disabled = true; // hidden during action anyway; still block double-submit
        try {
          const r = await fetch("/action", {
            method: "POST",
            credentials: "include",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ text })
          });
          const s = await r.json();
          render(s);
          cmd.value = "";
        } finally {
          btn.disabled = false;
        }
      }

      async function init() {
        try {
          render(await fetchState());
        } catch (e) {
          log.textContent = "Failed to load initial state.\n" + (e && e.message ? e.message : e);
        }

        btn.addEventListener("click", async () => {
          await callPrimary();
        });

        // Single input for everything: Enter either submits action or continues
        cmd.addEventListener("keydown", async (e) => {
          if (e.key !== "Enter") return;
          e.preventDefault();
          try {
            const s = await fetchState();
            if (s.mode === "awaiting_action") {
              const text = cmd.value.trim();
              await callAction(text);
            } else if (s.mode === "awaiting_continue" || s.mode === "awaiting_start") {
              await callPrimary();
            } // mode "over": do nothing
          } catch (err) {
            // Keep UI usable even on transient network errors
            console.error(err);
          }
        });

        // Initial focus/scroll
        cmd.focus();
        scrollBottom();
      }

      init();
    </script>
  </body>
</html>